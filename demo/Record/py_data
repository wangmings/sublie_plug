['socket创建服务器', '\n\nimport socket\n                \n# 创建 socket 对象\nserversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM) \n                \nserversocket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #就是它，在bind前加\n# 绑定端口号\nserversocket.bind((\'127.0.0.1\', 9999))\n\n# 设置最大连接数，超过后排队\nserversocket.listen(5)\n\nwhile True:\n\n    # 建立客户端连接\n    clientsocket,addr = serversocket.accept()      \n\n    print("连接地址: %s" % str(addr))\n                    \n\n    # 接收客服端发送的数据\n    msg = clientsocket.recv(1024)\n    content = msg.decode(\'utf-8\')\n    index = Reg(content)     \n\n    clientsocket.close()\n                \n']
['匹配字符串括号里面的字符', "\n\nimport re\nstring = 'hello(love)line'\n\nregg = re.compile(r'[[](.*?)[]]', re.S)  #最小匹配\nregg = re.findall(regg, string)\nreturn regg[0]\n            \n"]
['文件写入', "\n# a+: 叠加写入 w:一次性写入\nwith open(filePath, 'a+',encoding='utf-8') as f:\nf.write('hello')\n"]
['逐行读取文件', "\n# 按行读取文件\nfor line in open(FilePath,'r',encoding='utf-8'):\n    print(line)\n       "]
['创建http服务器', '\n# 创建服务器 \nfrom wsgiref.simple_server import make_server as createServer   \n\n# 处理客服端发送的请求\ndef response(req, res):\n\n    # 获取客服端发送的json数据：\n    # 类型转换流程：JSON_DATA[type:byte] --> JSON_DATA[type:strin] --> JSON_DATA[type:dict]\n    json_byte = req["wsgi.input"].read(int(req.get("CONTENT_LENGTH", 0)))\n    json_str = json_byte.decode(\'utf-8\') \n    json_dict = json.loads(json_str)     \n\n\n    # 响应状态码--以及数据\n    res(\'200 OK\', [(\'Content-Type\', \'text/html\')])\n    return [b\'<h1>Hello, Python web!</h1>\']\n\n\n# 创建WEB服务器\nhttpd = createServer(\'127.0.0.1\', 8282, response)\nprint(\'开始监听端口: 8282 HTTP请求..............\')\n\n# 开始监听HTTP请求:\nhttpd.serve_forever()   \n\n# 关闭服务器\n# httpd.server_close() \n\n']
['创建客服端请求', "\n# 创建客服端：发送json数据\n# 注意：requets必须得到返回：没有返回就会阻塞\nimport requests \ndata = {'js':'hello'}\nurl = 'http://127.0.0.1:8080'\nreq = requests.post(url,data=json.dumps(data))\ncontent = req.content.decode('utf8')\nprint(content)   \n\n"]
['执行命令shell', "\n# 执行shell\nimport subprocess  \n\ndef RunShell(cmd):\n    results = subprocess.Popen(cmd, shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)\n    err = results.stderr.read()\n    if len(err) == 0:\n        out = results.stdout.read()\n        return bytes(out).decode('utf8')\n    else:\n        print('-----------------------')\n        print('命令执行失败: ' + cmd)\n        print(bytes(err).decode('utf8'))\n\nRunShell('ls')\n"]
['Python爬虫', '\n\nimport requests \n# HTML解析库\nfrom bs4 import BeautifulSoup\n\n# 请求的路径\nurl = \'http://www.baidu.com\'\n\n# 发送的数据\ndata = {\n    \'inputtext\': text,\n    \'type\': \'AUTO\'\n}\n\n# 模拟游览器：设置请求头相关的属性\nheaders = {\n    \'User-Agent\': \'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1\',\n    \'Origin\': \'http://m.youdao.com\',  # 请求头最初是从youdao发起的，Origin只用于post请求\n    \'Referer\': \'http://m.youdao.com/translate\',  # Referer则用于所有类型的请求\n}\n\n# 发送请求:并返回html,json数据\nr = requests.post(post, headers=headers, data=data)\ncontent = r.content\n\n# 通过状态码判断是否请求成功\nif r.status_code == requests.codes.ok:\n    soup = BeautifulSoup(content, \'html.parser\', from_encoding=\'utf-8\')\n    getText = soup.find(id="translateResult").li.get_text()\n\n\n']
['创建线程、进程', "\n\n# 参考地址\n# http://c.biancheng.net/python/thread/\n\n# 线程\nimport threading \n# 进程\nfrom multiprocessing import Process \n\ndef fun(a):\n    print(a)\n\n# 创建线程\nt = threading.Thread(target=fun,args=('hello',))\n# 线程定时循环执行\nt = threading.Timer(1, fun)   \n# 开始执行线程\nt.start()\n# 等待线程结束\nt.join()\n\n"]
['填写', '\n\n\n# 多个光标编辑数字叠加：super+shfit+l\nclass numberCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        view = self.view\n        selection = view.sel()\n        for i in range(0,len(selection)):\n            view.insert(edit,selection[i].begin(),str(i))\n\n\n\n\n\n# 自定义代码补全 \nclass SymbolComplete(sublime_plugin.EventListener):\n\n    def on_query_completions(self, view, prefix, locations):\n        global num\n        name = view.file_name()\n        ftype = name.split(\'.\')[1]\n        _list = [\n            ["_js"+"\\tCODE (查找)","JS:${1:查找代码段}"],\n            ["_css"+"\\tCODE (查找)","CSS:${1:查找代码段}"],\n            ["print"+"\\tabc (打印)", "print(${1:打印})"],\n            ["_e"+"\\t<<EOF (开始)", "<<EOF: 代码描述: {${1:填写}} 语言类型: {填写} \n', '\n\n\n# 多个光标编辑数字叠加：super+shfit+l\nclass numberCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        view = self.view\n        selection = view.sel()\n        for i in range(0,len(selection)):\n            view.insert(edit,selection[i].begin(),str(i))\n\n\n\n\n\n# 自定义代码补全 \nclass SymbolComplete(sublime_plugin.EventListener):\n\n    def on_query_completions(self, view, prefix, locations):\n        global num\n        name = view.file_name()\n        ftype = name.split(\'.\')[1]\n        _list = [\n            ["_js"+"\\tCODE (查找)","JS:${1:查找代码段}"],\n            ["_css"+"\\tCODE (查找)","CSS:${1:查找代码段}"],\n            ["print"+"\\tabc (打印)", "print(${1:打印})"],\n            ["_e"+"\\t<<EOF (开始)", "<<EOF: 代码描述: {${1:填写}} 语言类型: {填写} ']
['填写', '\n\n\n# 多个光标编辑数字叠加：super+shfit+l\nclass numberCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        view = self.view\n        selection = view.sel()\n        for i in range(0,len(selection)):\n            view.insert(edit,selection[i].begin(),str(i))\n\n\n\n\n\n# 自定义代码补全 \nclass SymbolComplete(sublime_plugin.EventListener):\n\n    def on_query_completions(self, view, prefix, locations):\n        global num\n        name = view.file_name()\n        ftype = name.split(\'.\')[1]\n        _list = [\n            ["_js"+"\\tCODE (查找)","JS:${1:查找代码段}"],\n            ["_css"+"\\tCODE (查找)","CSS:${1:查找代码段}"],\n            ["print"+"\\tabc (打印)", "print(${1:打印})"],\n            ["_e"+"\\t<<EOF (开始)", "<<EOF: 代码描述: {${1:填写}} 语言类型: {填写} \n', '\n\n\n# 多个光标编辑数字叠加：super+shfit+l\nclass numberCommand(sublime_plugin.TextCommand):\n    def run(self, edit):\n        view = self.view\n        selection = view.sel()\n        for i in range(0,len(selection)):\n            view.insert(edit,selection[i].begin(),str(i))\n\n\n\n\n\n# 自定义代码补全 \nclass SymbolComplete(sublime_plugin.EventListener):\n\n    def on_query_completions(self, view, prefix, locations):\n        global num\n        name = view.file_name()\n        ftype = name.split(\'.\')[1]\n        _list = [\n            ["_js"+"\\tCODE (查找)","JS:${1:查找代码段}"],\n            ["_css"+"\\tCODE (查找)","CSS:${1:查找代码段}"],\n            ["print"+"\\tabc (打印)", "print(${1:打印})"],\n            ["_e"+"\\t<<EOF (开始)", "<<EOF: 代码描述: {${1:填写}} 语言类型: {填写} ']
